!=======================================================================
! Generated by  : PSCAD v4.6.2.0
!
! Warning:  The content of this file is automatically generated.
!           Do not modify, as any changes made here will be lost!
!-----------------------------------------------------------------------
! Component     : Main
! Description   : 
!-----------------------------------------------------------------------


!=======================================================================

      SUBROUTINE MainDyn()

!---------------------------------------
! Standard includes
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 'emtstor.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's2.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'fnames.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'matlab.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations
!---------------------------------------

!     SUBR    3PHVSRC       ! 3-Phase Source model

!---------------------------------------
! Variable Declarations
!---------------------------------------


! Subroutine Arguments

! Electrical Node Indices

! Control Signals
      INTEGER  fault_type, IT_1, BRK, fault_loc
      INTEGER  IT_2(12), IT_3, type1, IT_4, type2
      INTEGER  type3, IT_5, IT_6, IT_7, BST_A
      INTEGER  BST_B, BST_C
      REAL     I3(4), I2(4), I1(4), I11, I12, I13
      REAL     I14, I21, I22, I23, I24, I31, I32
      REAL     I33, I34, Rg, fault_time
      REAL     brk_delay, fault_res, brk_time
      REAL     IL(3), Itest, US(3), IS(3), US_rms
      REAL     UL(3)

! Internal Variables
      LOGICAL  LVD1_1
      INTEGER  IVD1_1, IVD1_2, IVD1_3, IVD1_4
      REAL     RVD1_1, RVD1_2, RVD1_3, RVD1_4

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER ISTOI, ISTOF, IT_0                  ! Storage Indices
      INTEGER IPGB                                ! Control/Monitoring
      INTEGER ISUBS, SS(5), IBRCH(5), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices
!---------------------------------------

! Dsdyn <-> Dsout transfer index storage

      NTXFR = NTXFR + 1

      TXFR(NTXFR,1) = NSTOL
      TXFR(NTXFR,2) = NSTOI
      TXFR(NTXFR,3) = NSTOF
      TXFR(NTXFR,4) = NSTOC

! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      ISTOI     = NSTOI
      NSTOI     = NSTOI + 27
      ISTOF     = NSTOF
      NSTOF     = NSTOF + 43
      IPGB      = NPGB
      NPGB      = NPGB + 22
      INODE     = NNODE + 2
      NNODE     = NNODE + 54
      NCSCS     = NCSCS + 0
      NCSCR     = NCSCR + 0

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 5

      DO IT_0 = 1,5
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 12

      IBRCH(2)     = NBRCH(SS(2))
      NBRCH(SS(2)) = NBRCH(SS(2)) + 12

      IBRCH(3)     = NBRCH(SS(3))
      NBRCH(SS(3)) = NBRCH(SS(3)) + 12

      IBRCH(4)     = NBRCH(SS(4))
      NBRCH(SS(4)) = NBRCH(SS(4)) + 18

      IBRCH(5)     = NBRCH(SS(5))
      NBRCH(SS(5)) = NBRCH(SS(5)) + 2
!---------------------------------------
! Transfers from storage arrays
!---------------------------------------

      I11      = STOF(ISTOF + 13)
      I12      = STOF(ISTOF + 14)
      I13      = STOF(ISTOF + 15)
      I14      = STOF(ISTOF + 16)
      I21      = STOF(ISTOF + 17)
      I22      = STOF(ISTOF + 18)
      I23      = STOF(ISTOF + 19)
      I24      = STOF(ISTOF + 20)
      I31      = STOF(ISTOF + 21)
      I32      = STOF(ISTOF + 22)
      I33      = STOF(ISTOF + 23)
      I34      = STOF(ISTOF + 24)
      Rg       = STOF(ISTOF + 25)
      fault_time = STOF(ISTOF + 26)
      brk_delay = STOF(ISTOF + 27)
      fault_res = STOF(ISTOF + 28)
      fault_type = STOI(ISTOI + 1)
      IT_1     = STOI(ISTOI + 2)
      BRK      = STOI(ISTOI + 3)
      brk_time = STOF(ISTOF + 29)
      fault_loc = STOI(ISTOI + 4)
      IT_3     = STOI(ISTOI + 17)
      type1    = STOI(ISTOI + 18)
      IT_4     = STOI(ISTOI + 19)
      type2    = STOI(ISTOI + 20)
      type3    = STOI(ISTOI + 21)
      Itest    = STOF(ISTOF + 33)
      IT_5     = STOI(ISTOI + 22)
      IT_6     = STOI(ISTOI + 23)
      IT_7     = STOI(ISTOI + 24)
      US_rms   = STOF(ISTOF + 40)
      BST_A    = STOI(ISTOI + 25)
      BST_B    = STOI(ISTOI + 26)
      BST_C    = STOI(ISTOI + 27)

! Array (1:3) quantities...
      DO IT_0 = 1,3
         IL(IT_0) = STOF(ISTOF + 29 + IT_0)
         US(IT_0) = STOF(ISTOF + 33 + IT_0)
         IS(IT_0) = STOF(ISTOF + 36 + IT_0)
         UL(IT_0) = STOF(ISTOF + 40 + IT_0)
      END DO

! Array (1:4) quantities...
      DO IT_0 = 1,4
         I3(IT_0) = STOF(ISTOF + 0 + IT_0)
         I2(IT_0) = STOF(ISTOF + 4 + IT_0)
         I1(IT_0) = STOF(ISTOF + 8 + IT_0)
      END DO

! Array (1:12) quantities...
      DO IT_0 = 1,12
         IT_2(IT_0) = STOI(ISTOI + 4 + IT_0)
      END DO


!---------------------------------------
! Electrical Node Lookup
!---------------------------------------


!---------------------------------------
! Configuration of Models
!---------------------------------------

      IF ( TIMEZERO ) THEN
         FILENAME = 'Main.dta'
         CALL EMTDC_OPENFILE
         SECTION = 'DATADSD:'
         CALL EMTDC_GOTOSECTION
      ENDIF
!---------------------------------------
! Generated code from module definition
!---------------------------------------


! 150:[tfaultn] Timed Fault Logic 
! Timed fault logic
      IT_3 = 0
      IF ( TIME .GE. 0.05 ) IT_3 = 1
      IF ( TIME .GE. (0.05+11111.0) ) IT_3 = 0

! 210:[consti] Integer Constant 

      type1 = 8

! 220:[consti] Integer Constant 

      type2 = 0

! 230:[mrun] Multiple Run Component 

! Multiple Run Variables Disabled:
      Rg = 0.2
      fault_time = 0.05
      brk_delay = 10.0
      fault_type = 0
      fault_loc = 0
      fault_res = 0.2
! End of Multiple Run Code

! 240:[pgb] Output Channel 'fault_time'

      PGB(IPGB+8) = fault_time

! 250:[consti] Integer Constant 

      type3 = 0

! 260:[pgb] Output Channel 'brk_delay'

      PGB(IPGB+9) = brk_delay

! 270:[mux_array] N channel multiplexer 
! Channel Decoder
      IT_2 = 0
      IF ((fault_loc .LE. 12).AND.(fault_loc .GT. 0)) THEN
        IT_2(fault_loc) = fault_type
      ENDIF

! 280:[datatap] Scalar/Array Tap 
      IT_6 = IT_2(2)

! 290:[pgb] Output Channel 'fault_type'

      PGB(IPGB+10) = REAL(fault_type)

! 300:[datatap] Scalar/Array Tap 
      IT_7 = IT_2(3)

! 310:[pgb] Output Channel 'Location'

      PGB(IPGB+11) = REAL(fault_loc)

! 320:[pgb] Output Channel 'fault_res'

      PGB(IPGB+12) = fault_res

! 330:[sumjct] Summing/Differencing Junctions 
      brk_time = + fault_time + brk_delay

! 360:[datatap] Scalar/Array Tap 
      IT_5 = IT_2(1)

! 370:[pgb] Output Channel 'Resistance'

      PGB(IPGB+14) = Rg

! 400:[tfaultn] Timed Fault Logic 
! Timed fault logic
      IT_4 = 0
      IF ( TIME .GE. fault_time ) IT_4 = 1
      IF ( TIME .GE. (fault_time+11111.0) ) IT_4 = 0

! 410:[tpflt] Three Phase Fault 
      CALL E3PHFLT1_EXE(SS(3), (IBRCH(3)+7), (IBRCH(3)+8), (IBRCH(3)+9),&
     & (IBRCH(3)+10), (IBRCH(3)+11), (IBRCH(3)+12),0,IT_4,type2,fault_re&
     &s)
      LVD1_1 = (OPENBR( (IBRCH(3)+7),SS(3)).AND.OPENBR( (IBRCH(3)+8),SS(&
     &3)).AND.OPENBR( (IBRCH(3)+9),SS(3)).AND.OPENBR( (IBRCH(3)+10),SS(3&
     &)).AND.OPENBR( (IBRCH(3)+11),SS(3)).AND.OPENBR( (IBRCH(3)+12),SS(3&
     &)))
      IVD1_1 = E_BtoI(LVD1_1)
      IF(FIRSTSTEP .OR. (IVD1_1 .NE. STORI(NSTORI))) THEN
         CALL PSCAD_AGI2(ICALL_NO,1019763324,1-IVD1_1,"AG1")
         STORI(NSTORI) = IVD1_1
      ENDIF
      NSTORI = NSTORI + 1

! 420:[tpflt] Three Phase Fault 
      CALL E3PHFLT1_EXE(SS(2), (IBRCH(2)+7), (IBRCH(2)+8), (IBRCH(2)+9),&
     & (IBRCH(2)+10), (IBRCH(2)+11), (IBRCH(2)+12),0,IT_3,type1,fault_re&
     &s)
      LVD1_1 = (OPENBR( (IBRCH(2)+7),SS(2)).AND.OPENBR( (IBRCH(2)+8),SS(&
     &2)).AND.OPENBR( (IBRCH(2)+9),SS(2)).AND.OPENBR( (IBRCH(2)+10),SS(2&
     &)).AND.OPENBR( (IBRCH(2)+11),SS(2)).AND.OPENBR( (IBRCH(2)+12),SS(2&
     &)))
      IVD1_1 = E_BtoI(LVD1_1)
      IF(FIRSTSTEP .OR. (IVD1_1 .NE. STORI(NSTORI))) THEN
         CALL PSCAD_AGI2(ICALL_NO,436739354,1-IVD1_1,"AG1")
         STORI(NSTORI) = IVD1_1
      ENDIF
      NSTORI = NSTORI + 1

! 430:[tfaultn] Timed Fault Logic 
! Timed fault logic
      IT_1 = 0
      IF ( TIME .GE. fault_time ) IT_1 = 1
      IF ( TIME .GE. (fault_time+11111.0) ) IT_1 = 0

! 440:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_EXE(0 ,SS(3) ,  (IBRCH(3)+6), 0, Rg, 0.0)

! 450:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_EXE(0 ,SS(3) ,  (IBRCH(3)+5), 0, Rg, 0.0)

! 460:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_EXE(0 ,SS(3) ,  (IBRCH(3)+4), 0, Rg, 0.0)

! 470:[tpflt] Three Phase Fault 
      CALL E3PHFLT1_EXE(SS(4), (IBRCH(4)+13), (IBRCH(4)+14), (IBRCH(4)+1&
     &5), (IBRCH(4)+16), (IBRCH(4)+17), (IBRCH(4)+18),0,IT_1,type3,fault&
     &_res)
      LVD1_1 = (OPENBR( (IBRCH(4)+13),SS(4)).AND.OPENBR( (IBRCH(4)+14),S&
     &S(4)).AND.OPENBR( (IBRCH(4)+15),SS(4)).AND.OPENBR( (IBRCH(4)+16),S&
     &S(4)).AND.OPENBR( (IBRCH(4)+17),SS(4)).AND.OPENBR( (IBRCH(4)+18),S&
     &S(4)))
      IVD1_1 = E_BtoI(LVD1_1)
      IF(FIRSTSTEP .OR. (IVD1_1 .NE. STORI(NSTORI))) THEN
         CALL PSCAD_AGI2(ICALL_NO,1658766998,1-IVD1_1,"AG1")
         STORI(NSTORI) = IVD1_1
      ENDIF
      NSTORI = NSTORI + 1

! 480:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_EXE(0 ,SS(2) ,  (IBRCH(2)+4), 0, Rg, 0.0)

! 490:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_EXE(0 ,SS(2) ,  (IBRCH(2)+5), 0, Rg, 0.0)

! 500:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_EXE(0 ,SS(2) ,  (IBRCH(2)+6), 0, Rg, 0.0)

! 510:[tbreakn] Timed Breaker Logic 
! Timed breaker logic
      IF ( TIMEZERO ) THEN
         BRK = 0
      ELSE
         BRK = 0
         IF ( TIME .GE. brk_time ) BRK = (1-0)
      ENDIF

! 520:[breaker3] 3 Phase Breaker 'BRK'
      IVD1_4 = NSTORI
      NSTORI = NSTORI + 3
! Three Phase Breaker
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+10),0.005,1000000.0,RTCF(NRTC&
     &F),0,NINT(1.0-REAL(BRK)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+11),0.005,1000000.0,RTCF(NRTC&
     &F),0,NINT(1.0-REAL(BRK)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+12),0.005,1000000.0,RTCF(NRTC&
     &F),0,NINT(1.0-REAL(BRK)))
!
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(1)+10),SS(1)))
      IVD1_2 = 2*E_BtoI(OPENBR( (IBRCH(1)+11),SS(1)))
      IVD1_3 = 2*E_BtoI(OPENBR( (IBRCH(1)+12),SS(1)))
      NRTCF = NRTCF + 1
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+0) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,525947723,IVD1_1,"BOpen1")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+1) .NE. IVD1_2)) THEN
         CALL PSCAD_AGI2(ICALL_NO,525947723,IVD1_2,"BOpen2")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+2) .NE. IVD1_3)) THEN
         CALL PSCAD_AGI2(ICALL_NO,525947723,IVD1_3,"BOpen3")
      ENDIF
      STORI(IVD1_4+0) = 2*E_BtoI(OPENBR( (IBRCH(1)+10),SS(1)))
      STORI(IVD1_4+1) = 2*E_BtoI(OPENBR( (IBRCH(1)+11),SS(1)))
      STORI(IVD1_4+2) = 2*E_BtoI(OPENBR( (IBRCH(1)+12),SS(1)))
      BST_A = IVD1_1
      BST_B = IVD1_2
      BST_C = IVD1_3

! 1:[source_3] Three Phase Voltage Source Model 2 'Source 1'
! Three Phase Source: Source 1  Type: R
!  
      RVD1_1 = RTCF(NRTCF)
      RVD1_2 = RTCF(NRTCF+1)
      RVD1_3  = 0.0*PI_BY180
      RVD1_4 = RTCF(NRTCF+3)
      NRTCF  = NRTCF + 4
      CALL EMTDC_3PHVSRC(SS(1), (IBRCH(1)+1), (IBRCH(1)+2), (IBRCH(1)+3)&
     &, RVD1_4, .TRUE., RVD1_1 , RVD1_2, RVD1_3)
!

! 1:[fixed_load] Fixed Load 
      CALL LOAD3P1_EXE(SS(4), (IBRCH(4)+7), (IBRCH(4)+8), (IBRCH(4)+9), &
     &(IBRCH(4)+10), (IBRCH(4)+11), (IBRCH(4)+12))

! 1:[battery] Generic battery model 'Bat1'
      IVD1_1=NSTORF
      CALL COMPONENT_ID(ICALL_NO,1121419505)
      CALL BATTERYCOEFF1_EXE(SS(5), (IBRCH(5)+1))

!---------------------------------------
! Feedbacks and transfers to storage
!---------------------------------------

      STOF(ISTOF + 13) = I11
      STOF(ISTOF + 14) = I12
      STOF(ISTOF + 15) = I13
      STOF(ISTOF + 16) = I14
      STOF(ISTOF + 17) = I21
      STOF(ISTOF + 18) = I22
      STOF(ISTOF + 19) = I23
      STOF(ISTOF + 20) = I24
      STOF(ISTOF + 21) = I31
      STOF(ISTOF + 22) = I32
      STOF(ISTOF + 23) = I33
      STOF(ISTOF + 24) = I34
      STOF(ISTOF + 25) = Rg
      STOF(ISTOF + 26) = fault_time
      STOF(ISTOF + 27) = brk_delay
      STOF(ISTOF + 28) = fault_res
      STOI(ISTOI + 1) = fault_type
      STOI(ISTOI + 2) = IT_1
      STOI(ISTOI + 3) = BRK
      STOF(ISTOF + 29) = brk_time
      STOI(ISTOI + 4) = fault_loc
      STOI(ISTOI + 17) = IT_3
      STOI(ISTOI + 18) = type1
      STOI(ISTOI + 19) = IT_4
      STOI(ISTOI + 20) = type2
      STOI(ISTOI + 21) = type3
      STOF(ISTOF + 33) = Itest
      STOI(ISTOI + 22) = IT_5
      STOI(ISTOI + 23) = IT_6
      STOI(ISTOI + 24) = IT_7
      STOF(ISTOF + 40) = US_rms
      STOI(ISTOI + 25) = BST_A
      STOI(ISTOI + 26) = BST_B
      STOI(ISTOI + 27) = BST_C

! Array (1:3) quantities...
      DO IT_0 = 1,3
         STOF(ISTOF + 29 + IT_0) = IL(IT_0)
         STOF(ISTOF + 33 + IT_0) = US(IT_0)
         STOF(ISTOF + 36 + IT_0) = IS(IT_0)
         STOF(ISTOF + 40 + IT_0) = UL(IT_0)
      END DO

! Array (1:4) quantities...
      DO IT_0 = 1,4
         STOF(ISTOF + 0 + IT_0) = I3(IT_0)
         STOF(ISTOF + 4 + IT_0) = I2(IT_0)
         STOF(ISTOF + 8 + IT_0) = I1(IT_0)
      END DO

! Array (1:12) quantities...
      DO IT_0 = 1,12
         STOI(ISTOI + 4 + IT_0) = IT_2(IT_0)
      END DO


!---------------------------------------
! Transfer to Exports
!---------------------------------------

!---------------------------------------
! Close Model Data read
!---------------------------------------

      IF ( TIMEZERO ) CALL EMTDC_CLOSEFILE
      RETURN
      END

!=======================================================================

      SUBROUTINE MainOut()

!---------------------------------------
! Standard includes
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 'emtstor.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's2.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'fnames.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'matlab.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations
!---------------------------------------

      REAL    EMTDC_VVDC    ! 
      REAL    VM3PH2        ! '3 Phase RMS Voltage Measurement'
      REAL    VBRANCH       ! 

!---------------------------------------
! Variable Declarations
!---------------------------------------


! Electrical Node Indices
      INTEGER  NT_1(3), NT_27(3)

! Control Signals
      INTEGER  type1, type2, type3
      REAL     I3(4), I2(4), I1(4), I11, I12, I13
      REAL     I14, I21, I22, I23, I24, I31, I32
      REAL     I33, I34, IL(3), Itest, US(3)
      REAL     IS(3), US_rms, UL(3)

! Internal Variables
      INTEGER  IVD1_1
      REAL     RVD1_1, RVD1_2

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER ISTOL, ISTOI, ISTOF, ISTOC, IT_0    ! Storage Indices
      INTEGER IPGB                                ! Control/Monitoring
      INTEGER ISUBS, SS(5), IBRCH(5), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices
!---------------------------------------

! Dsdyn <-> Dsout transfer index storage

      NTXFR = NTXFR + 1

      ISTOL = TXFR(NTXFR,1)
      ISTOI = TXFR(NTXFR,2)
      ISTOF = TXFR(NTXFR,3)
      ISTOC = TXFR(NTXFR,4)

! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      IPGB      = NPGB
      NPGB      = NPGB + 22
      INODE     = NNODE + 2
      NNODE     = NNODE + 54
      NCSCS     = NCSCS + 0
      NCSCR     = NCSCR + 0

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 5

      DO IT_0 = 1,5
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 12

      IBRCH(2)     = NBRCH(SS(2))
      NBRCH(SS(2)) = NBRCH(SS(2)) + 12

      IBRCH(3)     = NBRCH(SS(3))
      NBRCH(SS(3)) = NBRCH(SS(3)) + 12

      IBRCH(4)     = NBRCH(SS(4))
      NBRCH(SS(4)) = NBRCH(SS(4)) + 18

      IBRCH(5)     = NBRCH(SS(5))
      NBRCH(SS(5)) = NBRCH(SS(5)) + 2
!---------------------------------------
! Transfers from storage arrays
!---------------------------------------

      I11      = STOF(ISTOF + 13)
      I12      = STOF(ISTOF + 14)
      I13      = STOF(ISTOF + 15)
      I14      = STOF(ISTOF + 16)
      I21      = STOF(ISTOF + 17)
      I22      = STOF(ISTOF + 18)
      I23      = STOF(ISTOF + 19)
      I24      = STOF(ISTOF + 20)
      I31      = STOF(ISTOF + 21)
      I32      = STOF(ISTOF + 22)
      I33      = STOF(ISTOF + 23)
      I34      = STOF(ISTOF + 24)
      type1    = STOI(ISTOI + 18)
      type2    = STOI(ISTOI + 20)
      type3    = STOI(ISTOI + 21)
      Itest    = STOF(ISTOF + 33)
      US_rms   = STOF(ISTOF + 40)

! Array (1:3) quantities...
      DO IT_0 = 1,3
         IL(IT_0) = STOF(ISTOF + 29 + IT_0)
         US(IT_0) = STOF(ISTOF + 33 + IT_0)
         IS(IT_0) = STOF(ISTOF + 36 + IT_0)
         UL(IT_0) = STOF(ISTOF + 40 + IT_0)
      END DO

! Array (1:4) quantities...
      DO IT_0 = 1,4
         I3(IT_0) = STOF(ISTOF + 0 + IT_0)
         I2(IT_0) = STOF(ISTOF + 4 + IT_0)
         I1(IT_0) = STOF(ISTOF + 8 + IT_0)
      END DO


!---------------------------------------
! Electrical Node Lookup
!---------------------------------------


! Array (1:3) quantities...
      DO IT_0 = 1,3
         NT_1(IT_0) = NODE(INODE + 0 + IT_0)
         NT_27(IT_0) = NODE(INODE + 15 + IT_0)
      END DO

!---------------------------------------
! Configuration of Models
!---------------------------------------

      IF ( TIMEZERO ) THEN
         FILENAME = 'Main.dta'
         CALL EMTDC_OPENFILE
         SECTION = 'DATADSO:'
         CALL EMTDC_GOTOSECTION
      ENDIF
!---------------------------------------
! Generated code from module definition
!---------------------------------------


! 10:[ammeter] Current Meter 'I11'
      I11 = ( CBR((IBRCH(1)+7), SS(1)))

! 20:[multimeter] Multimeter 
      IVD1_1 = NRTCF
      NRTCF  = NRTCF + 5
      US(1) = ( CBR((IBRCH(1)+4), SS(1)))
      US(2) = ( CBR((IBRCH(1)+5), SS(1)))
      US(3) = ( CBR((IBRCH(1)+6), SS(1)))
      IS(1) = EMTDC_VVDC(SS(1), NT_1(1), 0)
      IS(2) = EMTDC_VVDC(SS(1), NT_1(2), 0)
      IS(3) = EMTDC_VVDC(SS(1), NT_1(3), 0)
      RVD1_1 = RTCF(IVD1_1+1) * VM3PH2(SS(1), NT_1(1), NT_1(2), NT_1(3),&
     & RTCF(IVD1_1+2))
      US_rms = RVD1_1

! 30:[ammeter] Current Meter 'I12'
      I12 = ( CBR((IBRCH(2)+3), SS(2)))

! 40:[ammeter] Current Meter 'I21'
      I21 = ( CBR((IBRCH(1)+8), SS(1)))

! 50:[ammeter] Current Meter 'I33'
      I33 = ( CBR((IBRCH(3)+3), SS(3)))

! 60:[ammeter] Current Meter 'I22'
      I22 = ( CBR((IBRCH(2)+1), SS(2)))

! 70:[ammeter] Current Meter 'I31'
      I31 = ( CBR((IBRCH(1)+9), SS(1)))

! 80:[ammeter] Current Meter 'I13'
      I13 = ( CBR((IBRCH(3)+2), SS(3)))

! 90:[ammeter] Current Meter 'I32'
      I32 = ( CBR((IBRCH(2)+2), SS(2)))

! 100:[multimeter] Multimeter 
      IVD1_1 = NRTCF
      NRTCF  = NRTCF + 5
      UL(1) = ( CBR((IBRCH(4)+1), SS(4)))
      UL(2) = ( CBR((IBRCH(4)+2), SS(4)))
      UL(3) = ( CBR((IBRCH(4)+3), SS(4)))
      IL(1) = EMTDC_VVDC(SS(4), NT_27(1), 0)
      IL(2) = EMTDC_VVDC(SS(4), NT_27(2), 0)
      IL(3) = EMTDC_VVDC(SS(4), NT_27(3), 0)

! 110:[ammeter] Current Meter 'I23'
      I23 = ( CBR((IBRCH(3)+1), SS(3)))

! 120:[ammeter] Current Meter 'I24'
      I24 = ( CBR((IBRCH(4)+4), SS(4)))

! 130:[ammeter] Current Meter 'I34'
      I34 = ( CBR((IBRCH(4)+5), SS(4)))

! 140:[ammeter] Current Meter 'I14'
      I14 = ( CBR((IBRCH(4)+6), SS(4)))

! 160:[datamerge] Merges data signals into an array 
      I1(1) = I11
      I1(2) = I12
      I1(3) = I13
      I1(4) = I14

! 170:[datamerge] Merges data signals into an array 
      I2(1) = I21
      I2(2) = I22
      I2(3) = I23
      I2(4) = I24

! 180:[datamerge] Merges data signals into an array 
      I3(1) = I31
      I3(2) = I32
      I3(3) = I33
      I3(4) = I34

! 190:[pgb] Output Channel 'I3'

      DO IVD1_1 = 1, 4
         PGB(IPGB+1+IVD1_1-1) = I3(IVD1_1)
      ENDDO

! 200:[pgb] Output Channel 'IL'

      DO IVD1_1 = 1, 3
         PGB(IPGB+5+IVD1_1-1) = IL(IVD1_1)
      ENDDO

! 210:[consti] Integer Constant 

      type1 = 8

! 220:[consti] Integer Constant 

      type2 = 0

! 250:[consti] Integer Constant 

      type3 = 0

! 340:[ammeter] Current Meter 'Itest'
      Itest = ( CBR((IBRCH(5)+2), SS(5)))

! 350:[pgb] Output Channel 'Itest'

      PGB(IPGB+13) = Itest

! 380:[pgb] Output Channel 'I2'

      DO IVD1_1 = 1, 4
         PGB(IPGB+15+IVD1_1-1) = I2(IVD1_1)
      ENDDO

! 390:[pgb] Output Channel 'I1'

      DO IVD1_1 = 1, 4
         PGB(IPGB+19+IVD1_1-1) = I1(IVD1_1)
      ENDDO

! 410:[tpflt] Three Phase Fault 
!
! Multi-phase Fault Currents
!
!

! 420:[tpflt] Three Phase Fault 
!
! Multi-phase Fault Currents
!
!

! 470:[tpflt] Three Phase Fault 
!
! Multi-phase Fault Currents
!
!

! 520:[breaker3] 3 Phase Breaker 'BRK'
! Three Phase Breaker Currents
      CALL BRK_POWER(SS(1), (IBRCH(1)+10), (IBRCH(1)+11), (IBRCH(1)+12),&
     &0,0,0,IVD1_1,0.02,RVD1_1,RVD1_2)

!---------------------------------------
! Feedbacks and transfers to storage
!---------------------------------------

      STOF(ISTOF + 13) = I11
      STOF(ISTOF + 14) = I12
      STOF(ISTOF + 15) = I13
      STOF(ISTOF + 16) = I14
      STOF(ISTOF + 17) = I21
      STOF(ISTOF + 18) = I22
      STOF(ISTOF + 19) = I23
      STOF(ISTOF + 20) = I24
      STOF(ISTOF + 21) = I31
      STOF(ISTOF + 22) = I32
      STOF(ISTOF + 23) = I33
      STOF(ISTOF + 24) = I34
      STOI(ISTOI + 18) = type1
      STOI(ISTOI + 20) = type2
      STOI(ISTOI + 21) = type3
      STOF(ISTOF + 33) = Itest
      STOF(ISTOF + 40) = US_rms

! Array (1:3) quantities...
      DO IT_0 = 1,3
         STOF(ISTOF + 29 + IT_0) = IL(IT_0)
         STOF(ISTOF + 33 + IT_0) = US(IT_0)
         STOF(ISTOF + 36 + IT_0) = IS(IT_0)
         STOF(ISTOF + 40 + IT_0) = UL(IT_0)
      END DO

! Array (1:4) quantities...
      DO IT_0 = 1,4
         STOF(ISTOF + 0 + IT_0) = I3(IT_0)
         STOF(ISTOF + 4 + IT_0) = I2(IT_0)
         STOF(ISTOF + 8 + IT_0) = I1(IT_0)
      END DO


!---------------------------------------
! Close Model Data read
!---------------------------------------

      IF ( TIMEZERO ) CALL EMTDC_CLOSEFILE
      RETURN
      END

!=======================================================================

      SUBROUTINE MainDyn_Begin()

!---------------------------------------
! Standard includes
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations
!---------------------------------------


!---------------------------------------
! Variable Declarations
!---------------------------------------


! Subroutine Arguments

! Electrical Node Indices

! Control Signals
      INTEGER  type1, type2, type3

! Internal Variables

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER IT_0                                ! Storage Indices
      INTEGER ISUBS, SS(5), IBRCH(5), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices
!---------------------------------------


! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      INODE     = NNODE + 2
      NNODE     = NNODE + 54
      NCSCS     = NCSCS + 0
      NCSCR     = NCSCR + 0

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 5

      DO IT_0 = 1,5
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 12

      IBRCH(2)     = NBRCH(SS(2))
      NBRCH(SS(2)) = NBRCH(SS(2)) + 12

      IBRCH(3)     = NBRCH(SS(3))
      NBRCH(SS(3)) = NBRCH(SS(3)) + 12

      IBRCH(4)     = NBRCH(SS(4))
      NBRCH(SS(4)) = NBRCH(SS(4)) + 18

      IBRCH(5)     = NBRCH(SS(5))
      NBRCH(SS(5)) = NBRCH(SS(5)) + 2
!---------------------------------------
! Electrical Node Lookup
!---------------------------------------


!---------------------------------------
! Generated code from module definition
!---------------------------------------


! 210:[consti] Integer Constant 
      type1 = 8

! 220:[consti] Integer Constant 
      type2 = 0

! 240:[pgb] Output Channel 'fault_time'

! 250:[consti] Integer Constant 
      type3 = 0

! 260:[pgb] Output Channel 'brk_delay'

! 270:[mux_array] N channel multiplexer 

! 280:[datatap] Scalar/Array Tap 

! 290:[pgb] Output Channel 'fault_type'

! 300:[datatap] Scalar/Array Tap 

! 310:[pgb] Output Channel 'Location'

! 320:[pgb] Output Channel 'fault_res'

! 330:[sumjct] Summing/Differencing Junctions 

! 360:[datatap] Scalar/Array Tap 

! 370:[pgb] Output Channel 'Resistance'

! 410:[tpflt] Three Phase Fault 
      CALL E3PHFLT1_CFG(1000000.0,0.0)

! 420:[tpflt] Three Phase Fault 
      CALL E3PHFLT1_CFG(1000000.0,0.0)

! 440:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(0 ,SS(3) ,  (IBRCH(3)+6), 0)

! 450:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(0 ,SS(3) ,  (IBRCH(3)+5), 0)

! 460:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(0 ,SS(3) ,  (IBRCH(3)+4), 0)

! 470:[tpflt] Three Phase Fault 
      CALL E3PHFLT1_CFG(1000000.0,0.0)

! 480:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(0 ,SS(2) ,  (IBRCH(2)+4), 0)

! 490:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(0 ,SS(2) ,  (IBRCH(2)+5), 0)

! 500:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(0 ,SS(2) ,  (IBRCH(2)+6), 0)

! 520:[breaker3] 3 Phase Breaker 'BRK'
      CALL COMPONENT_ID(ICALL_NO,525947723)
      RTCF(NRTCF) = ABS(0.0)
      NRTCF = NRTCF + 1

! 1:[source_3] Three Phase Voltage Source Model 2 'Source 1'
      CALL E_BRANCH_CFG( (IBRCH(1)+1),SS(1),1,0,0,1.0,0.0,0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+2),SS(1),1,0,0,1.0,0.0,0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+3),SS(1),1,0,0,1.0,0.0,0.0)
      RTCF(NRTCF)   = 220.0*SQRT_2*SQRT_1BY3
      RTCF(NRTCF+1) = 50.0*TWO_PI
      RTCF(NRTCF+3) = 0.01
      NRTCF = NRTCF + 4

! 1:[fixed_load] Fixed Load 
      CALL LOAD1P1_CFG(179.6292,50.0,200.0,100.0,2.0,2.0,0.0,0.0)

! 1:[battery] Generic battery model 'Bat1'
      CALL COMPONENT_ID(ICALL_NO,1121419505)
      CALL BATTERYCOEFF1_CFG(SS(5), (IBRCH(5)+1),0.12,1.15,1.03,0.0065,0&
     &.95,0.4,100.0,0.005,20.0)

      RETURN
      END

!=======================================================================

      SUBROUTINE MainOut_Begin()

!---------------------------------------
! Standard includes
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations
!---------------------------------------


!---------------------------------------
! Variable Declarations
!---------------------------------------


! Subroutine Arguments

! Electrical Node Indices
      INTEGER  NT_1(3), NT_27(3)

! Control Signals
      INTEGER  type1, type2, type3

! Internal Variables
      INTEGER  IVD1_1

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER IT_0                                ! Storage Indices
      INTEGER ISUBS, SS(5), IBRCH(5), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices
!---------------------------------------


! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      INODE     = NNODE + 2
      NNODE     = NNODE + 54
      NCSCS     = NCSCS + 0
      NCSCR     = NCSCR + 0

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 5

      DO IT_0 = 1,5
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 12

      IBRCH(2)     = NBRCH(SS(2))
      NBRCH(SS(2)) = NBRCH(SS(2)) + 12

      IBRCH(3)     = NBRCH(SS(3))
      NBRCH(SS(3)) = NBRCH(SS(3)) + 12

      IBRCH(4)     = NBRCH(SS(4))
      NBRCH(SS(4)) = NBRCH(SS(4)) + 18

      IBRCH(5)     = NBRCH(SS(5))
      NBRCH(SS(5)) = NBRCH(SS(5)) + 2
!---------------------------------------
! Electrical Node Lookup
!---------------------------------------


! Array (1:3) quantities...
      DO IT_0 = 1,3
         NT_1(IT_0) = NODE(INODE + 0 + IT_0)
         NT_27(IT_0) = NODE(INODE + 15 + IT_0)
      END DO

!---------------------------------------
! Generated code from module definition
!---------------------------------------


! 20:[multimeter] Multimeter 
      IVD1_1 = NRTCF
      NRTCF  = NRTCF + 5
      IF (ABS(1.0) .GT. 1.0E-20) THEN
        RTCF(IVD1_1+1) = 1.0/ABS(1.0)
      ELSE
        RTCF(IVD1_1+1) = 1.0
      ENDIF
      RTCF(IVD1_1+2) = 0.02

! 100:[multimeter] Multimeter 
      IVD1_1 = NRTCF
      NRTCF  = NRTCF + 5

! 160:[datamerge] Merges data signals into an array 

! 170:[datamerge] Merges data signals into an array 

! 180:[datamerge] Merges data signals into an array 

! 190:[pgb] Output Channel 'I3'

! 200:[pgb] Output Channel 'IL'

! 210:[consti] Integer Constant 
      type1 = 8

! 220:[consti] Integer Constant 
      type2 = 0

! 250:[consti] Integer Constant 
      type3 = 0

! 350:[pgb] Output Channel 'Itest'

! 380:[pgb] Output Channel 'I2'

! 390:[pgb] Output Channel 'I1'

      RETURN
      END

